
# Лабораторная работа № 2 <!-- omit in toc -->
# Классы <!-- omit in toc -->

- [1 Теоретические сведения](#1-теоретические-сведения)
  - [1.1 Классы, объекты и методы](#11-классы-объекты-и-методы)
  - [1.2 Сокрытие данных и спецификаторы доступа](#12-сокрытие-данных-и-спецификаторы-доступа)
  - [1.3 Конструкторы](#13-конструкторы)
  - [1.4 Списки инициализации в конструкторах](#14-списки-инициализации-в-конструкторах)
  - [1.5 Константность](#15-константность)
  - [1.6 Перегрузка операторов](#16-перегрузка-операторов)
- [2 Обязательное задание](#2-обязательное-задание)
  - [2.1 Общее задание](#21-общее-задание)
  - [2.2 Варианты](#22-варианты)
  - [2.3 Нормы](#23-нормы)
  - [2.4 Пример](#24-пример)
    - [Задание](#задание)
    - [Памятка по комплексным числам](#памятка-по-комплексным-числам)
    - [Решение](#решение)
      - [Заголовочный файл `complex.h`](#заголовочный-файл-complexh)
      - [Файл исходного кода `complex.cpp`](#файл-исходного-кода-complexcpp)
      - [Файл исходного кода `main.cpp`](#файл-исходного-кода-maincpp)
      - [Файл сценария сборки `CMakeLists.txt`](#файл-сценария-сборки-cmakeliststxt)
- [3 Факультативное задание](#3-факультативное-задание)

# 1 Теоретические сведения

## 1.1 Классы, объекты и методы

В программировании класс - это описание собственного типа данных; а объект - конкретный экземпляр класса.
Описание класса состоит из описания данных (полей), которые смогут хранить экземпляры класса (объекты)
и описания набора действий (методов), которые над этими данными могут производиться
(другими словами, это операции, которые можно совершить над объектом).

Например:
- класс "прямоугольник" (со сторонами, параллельными осям координат):
  - состояние (поля):
    - координаты левой нижней вершины;
    - координаты правой верхней вершины.
  - возможные действия над объектом (методы):
    - вычислить площадь;
    - вычислить периметр;
    - нарисовать.
  - примеры объектов:
    - прямоугольник с вершинами в точках (0, 0) и (1, 1);
    - прямоугольник с вершинами в точках (2, 3) и (4, 5).
- класс "полином второй степени с вещественными коэффициентами" ($ax^2 + bx + c$):
  - состояние (поля):
    - коэффициент $a$;
    - коэффициент $b$;
    - коэффициент $c$.
  - возможные действия над объектом (методы):
    - вычислить значение полинома для указанного значения $x$.
  - примеры объектов:
    - полином $3x^2 + 2x + 1$;
    - полином $x^2 + 2x + 3$.

Поля описывают то, какие данные смогут хранить экземпляры.
Конкретные значения сохраняются уже внутри объектов.
Внутри методов класса к полям можно обращаться непосредственно по их именам.

Методы - это функции, которые могут применяться к экземплярам класса.
Они объявляются внутри класса и предназначены для работы с его объектами.
**Метод можно вызвать только у конкретного объекта.**

Рассмотрим пример.
Опишем класс (структуру) комплексных чисел и снабдим его методом вычисления модуля комплексного числа.
В коде программы создадим два объекта, соответствующих комплексным числам $1+j$ и $3+4j$.
Выведем на экран модули этих чисел.

```cpp
// ⚠ Для простоты примера здесь не соблюдены все нормы.
// Пример с учётом всех норм приведён в подразделе 2.4 "Пример".

#include <cmath>
#include <iostream>

using namespace std;

struct Complex {
  float re;
  float im;

  double abs() {
    return sqrt(re * re + im * im);
  }
};

int main() {
  Complex c1;
  c1.re = 1;
  c1.im = 1;

  Complex c2;
  c2.re = 3;
  c2.im = 4;

  cout << c1.abs() << '\n';
  cout << c2.abs() << '\n';
}
```

Ещё раз обратим внимание, что в отличие от обычных функций, метод нельзя вызвать просто так, без контекста.
Для вычисления модуля комплексного числа из примера выше следующее выражение некорректно:
```cpp
abs(); // Некорректно: не указан объект, для которого вызывается метод!
```

Правильный вызов метода выглядит следующим образом:
```cpp
obj.abs(); // Вместо obj должно стоять имя любого существующего объекта (или выражение) типа Complex
```



## 1.2 Сокрытие данных и спецификаторы доступа

Инкапсуляция - это принцип, согласно которому любой класс должен рассматриваться как чёрный ящик -
пользователь класса должен видеть и использовать только интерфейсную часть класса
(т. е. часть, предназначенную для использования внешним кодом) и не вникать в его внутреннюю реализацию.
Поэтому данные принято инкапсулировать в классе таким образом,
чтобы доступ к ним по чтению или записи осуществлялся не напрямую, а с помощью методов.
Принцип инкапсуляции позволяет минимизировать число связей между классами и,
соответственно, упростить независимую реализацию и модификацию классов.

Методы, предназначенные для чтения/записи полей в объекте
называются get/set-методами (методами чтения/записи).

Область видимости членов класса (полей и методов) указывается с помощью одного из спецификаторов доступа:
- `public` - открытые члены класса (доступны как внутри, так и вне класса);
- `private` - закрытые члены класса (доступны только внутри класса);
- `protected` - защищённые члены класса (данный спецификатор будет рассмотрен в одной из последующих лабораторных работ).

Синтаксис использования спецификаторов доступа:
```cpp
class T {
private:
  // Закрытые члены класса

public:
  // Открытые члены класса
};
```

В C++ единственное различие между `class` и `struct` заключается в области видимости по умолчанию,
которая применяется, если явно не указан ни один из спецификаторов доступа:
- в `class` это `private`;
- в `struct` это `public`.

Обратим внимание, что в приведённом выше примере с классом `Complex` оба поля и метод являются открытыми
(т. к. использовалось ключевое слово `struct` без явного указания спецификатора доступа).
Именно поэтому к ним возможен прямой доступ из функции `main`.
Заметим, что такой пример нарушает принцип инкапсуляции (это было сделано для простоты демонстрации),
так как позволяет обращаться к данным класса напрямую, а не через методы чтения-записи.
Пример концептуально более правильного кода будет приведён в [конце](#24-пример) документа.

В рамках данного курса имена всех приватных полей будут начинаться с символа нижнего подчёркивания (`_`).
- Это позволяет при взгляде на тело метода сразу определить принадлежность переменной -
  является ли она полем текущего объекта (название начинается с `_`) или
  локальной переменной/параметром (название не начинается с `_`).
- Это позволяет избежать конфликта имён (и необходимости использования `this`) в конструкторах и `set`-методах,
  которые, как правило, имеют параметры, совпадающие по именам с полями.



## 1.3 Конструкторы

Конструкторы - это специальные методы, предназначенные для инициализации полей (состояния) объекта.
Конструкторы имеют то же имя, что и сам класс и не имеют никакого выходного значения (не указывается даже `void`).
Для класса допустимо определить несколько конструкторов с различными параметрами
(т. е. конструкторы можно перегружать).

Пример перегрузки конструкторов для приведённого класса комплексных чисел:
```cpp
// ⚠ Для простоты примера здесь не соблюдены все нормы.
// Пример с учётом всех норм приведён в подразделе 2.4 "Пример".

class Complex {
private:
  float _re;
  float _im;

public:
  // Конструктор по умолчанию (без параметров)
  Complex() {
    _re = 0;
    _im = 0;
  }

  // Конструктор с параметрами
  Complex(double re, double im) {
    _re = re;
    _im = im;
  }

  // ... (другие члены класса)
};
```

Если в классе не объявлен ни один конструктор, то компилятором будет
сгенерирован **конструктор по умолчанию** (без параметров).
Сгенерированный конструктор вызывает конструкторы по умолчанию для всех полей-объектов,
но никак не инициализирует поля примитивных типов (`int`, `float` и т. д.) и указатели.
Непроинициализированные поля имеют произвольное значение, что приводит к ошибкам в процессе работы программы.

Конструктор, принимающий по ссылке константный объект текущего класса, называется **конструктором копирования**.
Конструктор копирования генерируется компилятором всегда
(независимо от наличия или отсутствия в классе других конструкторов),
если только класс не предоставляет собственное явное определение конструктора копирования.
Генерируемая компилятором неявная версия копирует все поля объекта по значению:
```cpp
class Complex {
private:
  float _re;
  float _im;

public:
  // Конструктор копирования - в данном случае его можно было ВООБЩЕ НЕ ОБЪЯВЛЯТЬ/ОПРЕДЕЛЯТЬ,
  // т. к. сгенерированная компилятором неявная версия делала бы то же самое!
  Complex(const Complex& other) {
    _re = other._re;
    _im = other._im;
  }

  // ... (другие члены класса)
};
```



## 1.4 Списки инициализации в конструкторах

При создании объекта, до того, как управление будет передано конструктору,
поля-объекты инициализируются конструкторами по умолчанию.
Рассмотрим класс `Circle`, объекты которого имеют поле `center` типа `Point`:

```cpp
// ⚠ Для простоты примера здесь не соблюдены все нормы.
// Пример с учётом всех норм приведён в подразделе 2.4 "Пример".

class Point {
public:
  // Здесь особого смысла в сокрытии данных нет,
  // поэтому для простоты поля сделаны открытыми
  float x;
  float y;
  
  Point() {
    x = 0;
    y = 0;
  }
  
  Point(float x, float y) {
    this->x = x;
    this->y = y;
  }
};

class Circle {
  Point _center;  
  float _radius;

public:
  Circle(Point center, float radius) {
    _center = center;
    _radius = radius;
  }
  
  // ... (другие члены класса)
};
```

До того, как в конструкторе `Circle` выполнится присваивание `_center = center;`
поле `_center` уже будет проинициализировано конструктором по умолчанию класса `Point`.
Такое поведение (избыточная инициализация конструктором по умолчанию)
в общем случае приводит к ненужным дополнительным затратам времени и памяти.

Решением является использование списков инициализации -
специальной конструкции вида `: field1(value1), field2(value2), ...`,
указываемой после списка параметров конструктора.

При использовании списков инициализации в вышеприведённом примере
тела конструкторов становятся вообще пустыми:

```cpp
// ⚠ Для простоты примера здесь не соблюдены все нормы.
// Пример с учётом всех норм приведён в подразделе 2.4 "Пример".

struct Point {
  float x;
  float y;
  
  Point() : x(0), y(0) { }
  
  Point(float x, float y) : x(x), y(y) { }
};

class Circle {
  Point _center;  
  float _radius;

public:
  Circle(Point center, float radius) : _center(center), _radius(radius) { }
  
  // ... (другие члены класса)
};
```

Такой подход является практичным (экономит память и время при инициализации сложных типов) и рекомендуемым.
В таком списке инициализации объект сложного типа сразу инициализируется нужным конструктором,
минуя конструктор по умолчанию.

Важным моментом является то, что при использовании списков инициализации **инициализация полей
выполняется в том порядке, в котором поля перечислены в самом классе, а не в том порядке,
в котором они указаны в списке инициализации**.

Приведём пример неправильного использования списка инициализации.

```cpp
struct BadClass {
  int a;
  int b;

  // НЕКОРРЕКТНОЕ ИСПОЛЬЗОВАНИЕ СПИСКА ИНИЦИАЛИЗАЦИИ

  // Инициализация полей будет идти в том порядке,
  // в котором они объявлены в самом классе: сначала a, потом b.

  // В приведённом ниже примере:
  // 1. Сначала будет проинициализировано поле a значением поля b.
  // Так как поле b ещё не проинициализировано,
  // то в a запишется произвольное значение.
  // 2. Поле b проинициализируется значением value.

  // В итоге выполнения такого конструктора поле a останется непроинициализированным.

  BadClass(int value) : b(value), a(b) { }
};
```

Во избежание таких ошибок строго рекомендуется перечислять поля в списке инициализации
в том же порядке, в котором они перечислены в самом классе.

Нормы:
- [C.47: Define and initialize member variables in the order of member declaration](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#c47-define-and-initialize-member-variables-in-the-order-of-member-declaration)
- [C.49: Prefer initialization to assignment in constructors](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#c49-prefer-initialization-to-assignment-in-constructors)



## 1.5 Константность

Указание модификатора `const` при объявлении переменных гарантирует, что переменная не будет изменена.
Для объектов дело обстоит немного сложнее в связи с тем, что компилятору необходимо запрещать
не только изменение данных объекта, но и вызовы тех методов, в которых эти данные могут быть изменены.
Для того чтобы отличать те методы, которые не меняют состояние объекта от остальных методов,
используют всё тот же модификатор `const`.

**Константный метод** - метод, который не изменяет состояние объекта (не изменяет поля).
В коде такой метод помечается модификатором `const` в заголовке метода после списка параметров.

Пример 1. Как правило, почти все get-методы не изменяют состояние объекта и могут быть сделаны константными.

Пример 2. В классе комплексных чисел метод вычисления модуля `abs`
не изменяет состояние объекта и может быть сделан константным:
```cpp
class Complex {
public:
  // Константный метод вычисления модуля
  double abs() const {
    return sqrt(_re * _re + _im * _im);
  }

  // ... (другие члены класса)
};
```

Обратим внимание, что наличие у метода модификатора `const`:
- **Накладывает ограничение на тело метода.**

  Внутри такого метода нельзя изменять поля и вызывать неконстантные методы.
- **Но при этом расширяет контекст, в котором этот метод может быть вызван.**

  Константный метод можно вызвать для любого (неконстантного и константного) объекта,
  тогда как неконстантный метод можно вызвать только для неконстантного объекта.

Если поле помечено модификатором [`mutable`](https://en.cppreference.com/w/cpp/language/cv#mutable_specifier),
то значение такого поля допускается изменять в константном методе.
- Такой модификатор полезен, если логическая константность объекта не совпадает с физической (см. лекции).
- В общем случае использования `mutable` следует избегать.

Нормы:
- [ES.25: Declare an object const or constexpr unless you want to modify its value later on](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#es25-declare-an-object-const-or-constexpr-unless-you-want-to-modify-its-value-later-on)



## 1.6 Перегрузка операторов

Рассмотрим следующий класс комплексных чисел:

```cpp
class Complex {
  float _re;
  float _im;

public:
  Complex(float re, float im) : _re(re), _im(im) { }

  float re() const {
    return _re;
  }

  float im() const {
    return _im;
  }

  Complex sum(const Complex& rhs) const {
    return Complex(_re + rhs._re, _im + rhs._im);
  }
};
```

При таком объявлении класса объекты `Complex` можно сложить только через вызов метода,
использовать стандартный оператор сложения `+` нельзя:
```cpp
Complex c1(1, 2);
Complex c2(-1, 3);
Complex r1 = c1.sum(c2); // OK
Complex r2 = c1 + c2;    // FAIL: оператор + не определён для операндов типа Complex
```

C++ позволяет перегружать стандартные операторы.
Перегрузка выглядит как определение новой функции с именем operator@,
где @ - идентификатор перегружаемого оператора.
Количество аргументов такой функции зависит от двух факторов:
- категория самого оператора - унарный, бинарный, n-арный;

  Например:
  - оператор сложения `+` является бинарным оператором (для выполнения операции нужно два операнда);
  - оператор инкремента `++` является унарным (для выполнения операции нужен один операнд).
- используемый вариант перегрузки оператора:
  - в виде глобальной функции (для n-арного оператора потребуется n параметров);
  - в виде члена класса (для n-арного оператора потребуется n-1 параметров,
    т. к. в роли первого операнда всегда будет выступать текущий объект).

Варианты перегрузки оператора `+` для класса `Complex`:
- в виде глобальной функции:
```cpp
Complex operator+(const Complex& lhs, const Complex& rhs) {
  return Complex(lhs.re() + rhs.re(), lhs.im() + rhs.im());
}
```
- в виде метода класса:
```cpp
class Complex {
public: 
  Complex operator+(const Complex& rhs) const {
    return Complex(_re + rhs._re, _im + rhs._im);
  }

  // ... (другие члены класса)
};
```

Теперь, когда оператор + перегружен для операндов типа `Complex`,
можно сложить два объекта типа `Complex` с помощью оператора:
```cpp
Complex c1(1, 2);
Complex c2(-1, 3);
Complex r1 = c1.sum(c2); // OK
Complex r2 = c1 + c2;    // OK
```

Отметим, что при перегрузке `+` логично перегрузить и оператор `+=`.
При этом реализация `+` должна сводиться к вызову `+=`, чтобы избежать дублирования логики.
Это касается и всех подобных операторов (`-` и `-=`, `*` и `*=`, и т. д.).

Пример реализации `+` и `+=`, где реализация `+` сведена к `+=`:
```cpp
class Complex {
public: 
  Complex& operator+=(const Complex& rhs) {
    _re += rhs._re;
    _im += rhs._im;
    return *this;
  }

  // ... (другие члены класса)
};

Complex operator+(Complex lhs, const Complex& rhs) {
    return lhs += rhs;
}
```

Отметим некоторые отличия между вариантами перегрузки оператора (в виде функции или метода):
- в функции первый операнд может иметь любой тип,
  тогда как в методе тип первого операнда строго фиксирован
  (это тип класса, к которому принадлежит метод);
- в методе имеется доступ к закрытым полям и методам объектов
  (если они того же типа, к которому принадлежит сам метод),
  тогда как в функции имеется доступ только к открытым членам любых объектов.

Полный список перегружаемых операторов и особенности их перегрузки можно посмотреть здесь:
[C++ Reference: operator overloading](https://en.cppreference.com/w/cpp/language/operators).

Нормы:
- [C.160: Define operators primarily to mimic conventional usage](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#c160-define-operators-primarily-to-mimic-conventional-usag)
- [C.167: Use an operator for an operation with its conventional meaning](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#c167-use-an-operator-for-an-operation-with-its-conventional-meaning)



# 2 Обязательное задание

## 2.1 Общее задание

- Реализовать класс согласно варианту.
  - Объявление класса должно быть предоставлено в заголовочном файле,
    а определение - в отдельном файле исходного кода (см. лекции).
  - Предусмотреть два конструктора:
    - по умолчанию (если он имеет смысл);
    - с параметрами.
  - Реализовать get-методы для доступа к данным и метод согласно варианту.
  - Перегрузить операторы согласно варианту.
  - Если в задании есть оператор `+` (или любой подобный оператор: `-`, `*`, `/` и т. п.),
    необходимо реализовать и соответствующий оператор `+=`.
    При этом реализация `+` должна сводиться к `+=`.
- Перегрузить оператор вывода.
- Запрещено использовать любые массивы, указатели и т. п.

Допускается на своё усмотрение доопределить любое количество методов и операторов,
которых, по вашему мнению, не хватает для полноценной работы с объектами вашего (согласно варианту) класса.



## 2.2 Варианты

1. **Класс рациональных чисел** (несократимая дробь)
   - Метод: вычислить новую дробь путём умножения текущей на некоторое целое число.
   - Операторы:
     - `+` - сложение дробей;
     - `*` - умножение дробей.

1. **Класс интервалов**
   - Метод: проверить, принадлежит ли указанное число интервалу.
   - Операторы:
     - `+` - объединение интервалов;
     - `*` - пересечение интервалов.

     В обоих операторах подразумевается, что интервалы пересекаются.
     Например, для интервалов $(1;~5)$ и $(3;~7)$:
     - объединением будет являться интервал $(1;~7)$;
     - пересечением будет являться интервал $(3;~5)$.

     Если в качестве операндов указаны непересекающиеся интервалы, вернуть интервал $(0;~0)$.

1. **Класс матриц размера 2×2**
   - Метод: вычислить произведение двух матриц.
   - Операторы:
     - `+` - сложение матриц;
     - `*` - умножение матрицы на число (предусмотреть коммутативность, где возможно).

1. **Класс векторов на плоскости**
   - Метод: вычислить сумму двух векторов.
   - Операторы:
     - `*` - умножение вектора на число (предусмотреть коммутативность, где возможно);
     - `==` `!=` - сравнение на равенство/неравенство.

1. **Класс векторов в пространстве**
   - Метод: вычислить векторное произведение двух векторов.
   - Операторы:
     - `*` - скалярное произведение векторов;
     - `==` `!=` - сравнение на равенство/неравенство.

1. **Класс прямоугольников** (задаётся вершинами; со сторонами, параллельными осям координат)

   Предусмотреть вспомогательный класс `Point` (точка на плоскости).
   - Метод: проверить, находится ли некая точка внутри прямоугольника.
   - Операторы:
     - `==`, `!=` - сравнение на равенство/неравенство.

1. **Класс окружностей**
   
   Предусмотреть вспомогательный класс `Point` (точка на плоскости).
   - Метод: проверить, находится ли некая точка внутри окружности.
   - Операторы:
     - `==` `!=` - сравнение на равенство/неравенство.

1. **Класс треугольников** (задаётся вершинами)

   Предусмотреть вспомогательный класс `Point` (точка на плоскости).
   - Метод: вычислить новый треугольник, полученный из текущего сдвигом на некоторую величину (сдвиг - параметр).
   - Операторы:
     - `==` `!=` - сравнение на равенство/неравенство.

1. **Класс квадратичных функций $f(x)=ax^2+bx+c$**
   - Метод: вычисление значения функции для указанного значения аргумента $x$.
   - Операторы:
     - `+` - сложение функций;
     - `*` - умножение функции на вещественное число (предусмотреть коммутативность, где возможно).

1. **Класс цилиндров** (вертикальной ориентации)
   
   Предусмотреть вспомогательный класс `Point` (точка в пространстве).
   - Метод: проверить, находится ли некая точка внутри цилиндра.
   - Операторы:
     - `==` `!=` - сравнение на равенство/неравенство.

1. **Класс отрезков на плоскости**
   
   Предусмотреть вспомогательный класс `Point` (точка на плоскости).
   - Метод: проверить, принадлежит ли некая точка отрезку (с некоторой задаваемой погрешностью $\epsilon$).
   - Операторы:
     - `==` `!=` - сравнение на равенство/неравенство.

1. **Класс прямых на плоскости** (задаётся коэффициентами $a$, $b$ и $c$ из уравнения $ax+by+c=0$)

   Предусмотреть вспомогательный класс `Point` (точка на плоскости; понадобится только для метода).
   - Метод: проверить, принадлежит ли некая точка прямой (с некоторой задаваемой погрешностью $\epsilon$).
   - Операторы:
     - `==` `!=` - сравнение на равенство/неравенство.

1. **Класс для работы с денежными суммами** (задаётся количеством рублей и копеек)
   - Метод: вычисление указанного процента от денежной суммы.
   - Операторы:
     - `+`, `-` - сложение и вычитание денежных сумм;
     - `==` `!=` - сравнение на равенство/неравенство.

1. **Класс длительности по времени** (задаётся часами, минутами и секундами)
   - Метод: вычисление суммы двух длительностей по времени.
   - Операторы:
     - `*` - умножение длительности на целое число (предусмотреть коммутативность, где возможно);
     - `==` `!=` - сравнение на равенство/неравенство.

1. **Класс значения угла** (задаётся градусами, минутами и секундами)
   - Метод: вычисление суммы двух углов.
   - Операторы:
     - `*` - умножение угла на целое число (предусмотреть коммутативность, где возможно);
     - `==` `!=` - сравнение на равенство/неравенство.



## 2.3 Нормы

- Все нормы из предыдущих лабораторных работ.
- [C.4: Make a function a member only if it needs direct access to the representation of a class](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#c4-make-a-function-a-member-only-if-it-needs-direct-access-to-the-representation-of-a-class)
- [C.9: Minimize exposure of members](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#c9-minimize-exposure-of-members)
- [C.20: If you can avoid defining default operations, do](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#c20-if-you-can-avoid-defining-default-operations-do)
- [C.41: A constructor should create a fully initialized object](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#c41-a-constructor-should-create-a-fully-initialized-object)
- [C.42: If a constructor cannot construct a valid object, throw an exception](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#c42-if-a-constructor-cannot-construct-a-valid-object-throw-an-exception)
- [C.44: Prefer default constructors to be simple and non-throwing](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#c44-prefer-default-constructors-to-be-simple-and-non-throwing)
- [* C.45: Don’t define a default constructor that only initializes data members; use in-class member initializers instead](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#c45-dont-define-a-default-constructor-that-only-initializes-data-members-use-in-class-member-initializers-instead)
- [* C.46: By default, declare single-argument constructors explicit](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#c46-by-default-declare-single-argument-constructors-explicit)
- [C.47: Define and initialize member variables in the order of member declaration](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#c47-define-and-initialize-member-variables-in-the-order-of-member-declaration)
- [* C.48: Prefer in-class initializers to member initializers in constructors for constant initializers](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#c48-prefer-in-class-initializers-to-member-initializers-in-constructors-for-constant-initializers)
- [C.49: Prefer initialization to assignment in constructors](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#c49-prefer-initialization-to-assignment-in-constructors)
- [C.160: Define operators primarily to mimic conventional usage](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#c160-define-operators-primarily-to-mimic-conventional-usag)
- [C.167: Use an operator for an operation with its conventional meaning](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#c167-use-an-operator-for-an-operation-with-its-conventional-meaning)
- [ES.25: Declare an object const or constexpr unless you want to modify its value later on](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#es25-declare-an-object-const-or-constexpr-unless-you-want-to-modify-its-value-later-on)



## 2.4 Пример

### Задание

- Реализовать класс "Комплексное число".
  - Реализовать метод вычисления модуля комплексного числа.
  - Перегрузить оператор сложения двух комплексных чисел.
    - Предусмотреть возможность указания в качестве любого из операндов вещественного числа (`float`).
- В функции `main` продемонстрировать работу метода и операторов.

⚠ Обратите внимание, что для простоты демонстрации в примере реализованы не все пункты общего задания.



### Памятка по комплексным числам

- Комплексное число определяется вещественной и мнимой частью.
- В алгебраической форме записывается как $a+bj$, где $j$ - мнимая единица (вместо $j$ может использоваться $i$).
- Основное свойство мнимой единицы: $j^2 = -1$.
- Сложение двух комплексных чисел:

  $(a+bj) + (c+dj) = (a+c) + (b+d)j$
- Прибавление к комплексному числу вещественного числа просто увеличивает его вещественную часть:

  $(a+bj) + r = (a+r) + bj$



### Решение

#### Заголовочный файл `complex.h`

```cpp
#pragma once

#include <iostream>

class Complex {
  float _re { 0 };
  float _im { 0 };

public:
  Complex() = default;
  Complex(float re, float im);

  float re() const;
  float im() const;

  float abs() const;

  Complex& operator+=(const Complex& rhs);
  Complex& operator+=(float rhs);
};

Complex operator+(Complex lhs, const Complex& rhs);
Complex operator+(Complex lhs, float rhs);
Complex operator+(float lhs, Complex rhs);

std::ostream& operator<<(std::ostream& stream, const Complex& c);
```



#### Файл исходного кода `complex.cpp`

```cpp
#include "complex.h"

#include <cmath>

using namespace std;

Complex::Complex(float re, float im) : _re(re), _im(im) { }

float Complex::re() const {
  return _re;
}

float Complex::im() const {
  return _im;
}

float Complex::abs() const {
  return sqrt(_re * _re + _im * _im);
}

Complex& Complex::operator+=(const Complex& rhs) {
  _re += rhs._re;
  _im += rhs._im;
  return *this;
}

Complex& Complex::operator+=(float rhs) {
  _re += rhs;
  return *this;
}

Complex operator+(Complex lhs, const Complex& rhs) {
  return lhs += rhs;
}

Complex operator+(Complex lhs, float rhs) {
  return lhs += rhs;
}

Complex operator+(float lhs, Complex rhs) {
  return rhs += lhs;
}

ostream& operator<<(ostream& stream, const Complex& c) {
  stream << c.re();

  if (c.im() >= 0) {
    stream << '+';
  }
  stream << c.im() << 'j';

  return stream;
}
```



#### Файл исходного кода `main.cpp`

```cpp
#include "complex.h"

using namespace std;

int main() {
  const Complex c1(-1, -1);
  const Complex c2(1, 2);
  const float unit = 1.0f;

  cout << "c1 = " << c1 << '\n';
  cout << "c2 = " << c2 << '\n';

  Complex r1 = c1 + c2;
  cout << " c1 + c2  = " << r1 << '\n';
  cout << "|c1 + c2| = " << r1.abs() << '\n';

  cout << " c1 + 1   = " << (c1 + unit) << '\n';
  cout << "  1 + c1  = " << (unit + c1) << '\n';

  return 0;
}
```



#### Файл сценария сборки `CMakeLists.txt`

При наличии нескольких файлов исходного кода, которые собираются в один исполняемый файл
(скажем, с названием, `lab2-complex`), при вызове `add_executable` в `CMakeLists.txt`
необходимо указать все файлы исходного кода:
```cmake
add_executable(lab2-complex
  "complex.cpp"
  "main.cpp"
)
```



# 3 Факультативное задание

1. Продемонстрировать работоспособность вашего проекта под операционной системой семейства Linux.
1. Написать [модульные тесты](https://ru.wikipedia.org/w/index.php?title=%D0%9C%D0%BE%D0%B4%D1%83%D0%BB%D1%8C%D0%BD%D0%BE%D0%B5_%D1%82%D0%B5%D1%81%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5&stable=1)
   для вашего класса.
   Пример с использованием библиотеки GoogleTest для написания модульных тестов приведен в конце текущего раздела.
   - Тестами должны быть покрыты только содержательные методы вашего класса с нетривиальной логикой.
     - Конструкторы и get/set-методы тестами не покрываются.
     - Если есть пара операторов, первый из которых сводится к вызову второго (например, `+` и `+=`),
       то тестами достаточно покрыть только первый (т. е. `+`).
     - Оператор вывода тестами не покрывается.
1. Вынести общую часть кода из основного приложения и модульных тестов в отдельную библиотеку.
   Альтернативная формулировка: вынести класс в отдельную библиотеку,
   а основное приложение и приложение с тестами линковать с этой библиотекой.
 
   Выполнение данного пункта никак не влияет на исходный код вашей программы,
   все изменения делаются исключительно в файле `CMakeLists.txt`.

   Данный пункт не сопровождается какой-либо теорией или примерами и
   подразумевает самостоятельную работу с документацией CMake.
   Некоторые полезные ссылки:
   [add_library](https://cmake.org/cmake/help/latest/command/add_library.html),
   [target_include_directories](https://cmake.org/cmake/help/latest/command/target_include_directories.html),
   [target_link_libraries](https://cmake.org/cmake/help/latest/command/target_link_libraries.html).
   
   P. S. Желательно не перемешивать файлы трёх разных целей сборки (библиотеки,
   основного приложения и приложения с тестами) в одной директории.
   Попробуйте их разместить в отдельных подпапках.



## Пример использования GoogleTest для написания модульных тестов <!-- omit in toc -->

Пусть есть проект со следующей файловой структурой (см. [2.4 Пример](#24-пример)):
- `CMakeLists.txt`;
- `complex.cpp`;
- `complex.h`;
- `main.cpp`.

Тесты с точки зрения структуры проекта представляют из себя обычное исполняемое приложение.
Пусть тесты будут содержаться в файле `complex_tests.cpp`.
Тогда для добавления отдельного исполняемего приложения с тестами (скажем, с названием `lab2-complex-tests`)
в `CMakeLists.txt` необходимо добавить следующие строки:
```cmake
# Подключаем библиотеку googletest
include(FetchContent)
FetchContent_Declare(googletest
  URL https://github.com/google/googletest/archive/refs/tags/v1.14.0.zip
)
set(gtest_force_shared_crt ON CACHE BOOL "" FORCE)
FetchContent_MakeAvailable(googletest)

# Объявляем исполняемое приложение с тестами lab2-complex-tests,
# которое использует библиотеку GTest::gtest_main
add_executable(lab2-complex-tests
  "complex.cpp"
  "complex_tests.cpp"
)
target_link_libraries(lab2-complex-tests GTest::gtest_main)
```

Обратим внимание, что после добавления вышеприведённых строк, при первом сохранении файла `CMakeLists.txt`,
приложению CMake может понадобиться некоторое время, чтобы скачать GoogleTest из интернета и
сделать его доступным для использования в проекте.

Сами тесты в файле `complex_tests.cpp` выглядят следующим образом:
```cpp
#include <gtest/gtest.h>

#include "complex.h"

const float EPSILON = 1E-6f;

TEST(ComplexAbsTests, Zero) {
  // Arrange
  Complex c(0, 0);

  // Act
  float a = c.abs();

  // Assert
  EXPECT_NEAR(a, 0, EPSILON);
}

TEST(ComplexAbsTests, NegativeNegative) {
  Complex c(-3, -4);

  float a = c.abs();

  EXPECT_NEAR(a, 5, EPSILON);
}

TEST(ComplexAbsTests, NegativePositive) {
  Complex c(-3, 4);

  float a = c.abs();

  EXPECT_NEAR(a, 5, EPSILON);
}

TEST(ComplexAbsTests, PositiveNegative) {
  Complex c(3, -4);

  float a = c.abs();

  EXPECT_NEAR(a, 5, EPSILON);
}

TEST(ComplexAbsTests, PositivePositive) {
  Complex c(3, 4);

  float a = c.abs();

  EXPECT_NEAR(a, 5, EPSILON);
}
```

Обратим внимание на следующие моменты.
- Каждый тест объявляется с помощью макроса `TEST(название_набора, название_теста)`.
  При этом названия набора и теста в кавычки не берутся.
- Тело каждого теста разделено на три логические секции (отделены друг от друга пустой строкой)
  согласно шаблону [Arrange-Act-Assert](https://tenchat.ru/media/97620-pattern-aaa-arrangeactassert-i-yego-antipatterny).
- Проверка равенства фактического и ожидаемого значений производится с помощью *утверждений*.
  Список доступных утверждений см. в официальной документации:
  [GoogleTest: Assertions Reference](https://google.github.io/googletest/reference/assertions.html).
  В примере выше для сравнения вещественных чисел используется `EXPECT_NEAR`.
- **Не объявляется и не определяется функция `main`.**
  Её определение предоставляется библиотекой GoogleTest, с которым линкуется ваше приложение (`GTest::gtest_main`).
  Это очень удобно: не нужно писать свой `main`, можно сразу сконцентрироваться на написании тестов.
- Для простоты демонстрации тестами в примере покрыт только метод `abs`.
  В общем случае тестами должны покрываться все содержательные методы/операторы с нетривиальной логикой.
- Для читабельности рекомендуется разносить тесты в отдельные файлы исходного кода.
  Скажем, отдельный файл для каждого набора тестов, т. е. для каждого тестируемого метода/оператора.
